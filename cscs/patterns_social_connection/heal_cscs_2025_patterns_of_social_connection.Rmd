---
title: "HEAL_CSCS_2025_patterns_of_social_connection"
author: "Jorge Andres Delgado-Ron"
date: "`r Sys.Date()`"
output: html_document
---

Step 0. Loading packages, opening dataset, and metadata

```{r setup}
# This pakcage runs the script below for all future packages using p_load()
if (!("pacman" %in% installed.packages()[, "Package"])) {
	# Install the 'pacman' package if it's not installed
	install.packages("pacman")
}

library("pacman")
p_load(here)
p_load(dplyr)
p_load(DataExplorer)
p_load(tableone)

load(here("cscs","public_data","CSCS2025_full_cleaned_deidentified_data_and_metadata.RData"))

```

Custom functions
```{r}

# Input variable as text
# Returns the unique label(s) and which data frame(s) contain it.

which_dataset <- function(variable){
levels(data$DATASET) <- c("baseline", "baseline", "cohort22", "cross22", "cohort23", "cross23", "cohort24", "cross24")
x <- data %>% select(DATASET, !!sym(variable)) %>% group_by(DATASET) %>% summarise(result = !all(is.na(!!sym(variable)))) %>% select(DATASET, result)  %>% arrange(as.character(DATASET))
y <- unique(labels$text[labels$new_var==variable])
z <- list(y,x)
return(z)
}

# Input list of variables
# Returns a dataframe with variables as rows and data frames as columns

which_datasets_group <- function(list_of_vars){
df_temp <- which_dataset(list_of_vars[1])[[2]]
colnames(df_temp)[2] <- list_of_vars[1]

for(i in 2:length(list_of_vars)){
x <-  which_dataset(list_of_vars[i])[[2]]
colnames(x)[2] <- list_of_vars[i]
df_temp <- merge(df_temp,x, by="DATASET")
}
rownames(df_temp) <- df_temp$DATASET

df <- as.data.frame(t(df_temp)) %>% mutate(variable_name=rownames(.)) %>% relocate(variable_name, .before = baseline) %>% slice(-1) %>% arrange(as.character(variable_name))
rownames(df) <-NULL
return(df)
}


```

Project-specific data cleaning
```{r}
data$CONNECTION_social_num_coworkers_and_classmates_p7d_grouped[is.na(data$CONNECTION_social_num_coworkers_and_classmates_p7d_grouped) & data$DEMO_student=="No" & data$WORK_hours_per_week==0] <- "None (0 People)"
data$CONNECTION_social_time_coworkers_and_classmates_p7d_grouped[is.na(data$CONNECTION_social_time_coworkers_and_classmates_p7d_grouped) & data$DEMO_student=="No" & data$WORK_hours_per_week==0] <- "No time"
data$CONNECTION_social_days_coworkers_and_classmates_p7d_grouped[is.na(data$CONNECTION_social_days_coworkers_and_classmates_p7d_grouped) & data$DEMO_student=="No" & data$WORK_hours_per_week==0] <- "None (0 Days)"

data$WORK_hours_per_week[data$DEMO_unable_to_work=="Unable to work" & is.na(data$WORK_hours_per_week) & !is.na(data$DEMO_unable_to_work)] <- 0
data$WORK_hours_per_week[data$DEMO_retired=="Retired" & is.na(data$WORK_hours_per_week) & !is.na(data$DEMO_retired)] <- 0
```

Step 2. Identifying variables 

In the dataset we have a series of variables capturing patterns of social connection:

•	CONNECTION_activities_...
•	CONNECTION_social_num_...
•	CONNECTION_social_time_...
•	CONNECTION_social_days_...


These variables are part of the **core survey**, and some appear in both the **cross-section** and **cohort** datasets.

### CONNECTION_activities Suffixes

There are three suffixes used for the `CONNECTION_activities` variables:

- **`_last`**  
  - **Question:** *"When was the last time you..."*  
  - **Applies to:** 2022 cross-section only

- **`_p3m`**  
  - **Question:** *"In the PAST THREE MONTHS, how often have you..."*  
  - **Applies to:** All other datasets

- **`_pm`**  
  - **Derived variable**  
  - **Purpose:** Attempts to capture both `_last` and `_p3m` within the **past month**  
  - **Values:** `"Yes"` | `"No"`

### Response Interpretation

- **"Yes" includes:**
  - For `_last`:  
    *"In the past... month, two weeks, week, 2 or 3 days, yesterday, earlier today"*
  - For `_p3m`:  
    *"A few times a month, monthly, weekly, a few times a week, daily"*

- **"No" includes:**
  - For `_last`:  
    *"Not in the past three months, one to three months ago"*
  - For `_p3m`:  
    *"Not in the past three months, Less than monthly"*


We used whether or not the activity occurred in the past month ("_pm") for cross-sectional analysis, but cohort analysis can use more granular data ("_p3m") and more variables.

```{r}
activities_last_month <- data %>% select(starts_with("CONNECTION_activities") & ends_with("_pm")) %>% colnames()

activities_past_three_months<- data %>% select(starts_with("CONNECTION_activities") & ends_with("_p3m")) %>% colnames()
activities_last <- data %>% select(starts_with("CONNECTION_activities") & ends_with("_last")) %>% colnames()


all_activities <- which_datasets_group(data %>% select(starts_with("CONNECTION_activities") & -ends_with("_num")) %>% colnames())
activities_var_use <- which_datasets_group(activities_last_month)

# Selecting activities that appear in all data frames
activities_vars <- activities_var_use %>% filter(if_all(2:8, ~ .x == "TRUE")) %>% select(variable_name) %>% unlist() %>% as.vector()

# Print activities in all data frames
activities_vars

# Print activities that are not included
activities_last_month[!activities_last_month %in% activities_vars]
```

The issues with social number are similar.
'How many close friends do you have?' is represented by the variable 'CONNECTION_social_num_close_friends_grouped'
'Over the past three months, how many people belonging to each of the following categories have you spent time socializing with? Close friends' is represented by the variable 'CONNECTION_social_num_close_friends_p3m'

Other variables that are similar but do not ask the same are 'CONNECTION_social_num_close_relationships' and 
'CONNECTION_social_num_close_relationships_preference' asking about current and ideal number of friends and family members


```{r}
connections <- data %>% select(starts_with("CONNECTION_social_num")) %>% colnames() %>% sort()
# connections[connections %>% stringr::str_ends("_grouped")]

redundant_vars <- c("CONNECTION_social_num_close_friends_p3m", #exists as group
                    "CONNECTION_social_num_coworkers_and_classmates_p7d", #combines two categories but as raw data
                    "CONNECTION_social_num_coworkers_p7d",  #original variable
                    "CONNECTION_social_num_classmates_p7d", #original variable
                    "CONNECTION_social_num_family_p7d", #original variable
                    "CONNECTION_social_num_friends_p7d", #original variable
                    "CONNECTION_social_num_neighbours_p7d") #original variable

social_num_var_use <- which_datasets_group(connections)
# social_num_var_use %>% filter(!variable_name %in% redundant_vars) %>% View()

# Variables in all datasets
number_of_social_connections_vars <- social_num_var_use %>% filter(!variable_name %in% redundant_vars) %>%
  filter(if_all(2:8, ~ .x == "TRUE")) %>% select(variable_name) %>% unlist() %>% as.vector()

number_of_social_connections_vars
```

CONNECTION_social_time asks 'In the PAST WEEK, how many hours in total did you spend socializing with others from the following groups?'
CONNECTION_social_days asks 'In the PAST WEEK, how many days did you spend at least 5 minutes socializing with people from the following groups?'

They are virtually the same question, however, the answers are not necessarily consistent.



```{r}
social_time <- data %>% select(starts_with("CONNECTION_social_time"), starts_with("CONNECTION_social_days")) %>% colnames() %>% sort()
# social_time[social_time %>% stringr::str_ends("_grouped")]
red_vars <- c("CONNECTION_social_days_coworkers_and_classmates_p7d","CONNECTION_social_days_coworkers_p7d","CONNECTION_social_days_classmates_p7d","CONNECTION_social_days_family_p7d","CONNECTION_social_days_friends_p7d","CONNECTION_social_days_neighbours_p7d")
red_vars <- c(red_vars, sub("_days_","_time_",red_vars))
  
social_time_var_use <- which_datasets_group(social_time)

# social_time_var_use %>% filter(!variable_name %in% red_vars) %>% View()

social_time_vars <- social_time_var_use %>% filter(!variable_name %in% red_vars) %>%
  filter(if_all(2:8, ~ .x == "TRUE")) %>% select(variable_name) %>% unlist() %>% as.vector()

social_time_vars

df_temp <- data[social_time_vars]
df_temp$consistent <- T
for(i in 1:4){
hours <-  social_time_vars[i+4]
days <-  social_time_vars[i]
df_temp$consistent[df_temp[days]=="None (0 Days)" & !is.na(df_temp[days]) & df_temp[hours] != "No time"] <- F
}

# 8.3% of respondents said they did not spend at least five minutes with one group and then reported at least 1 hour of time spent together in the last week.

round(prop.table(table(df_temp$consistent)),2)
```
```{r}
# Listing all variables from social activities and time spent together
social_patterns_vars <- c(activities_last_month,number_of_social_connections_vars,social_time_vars)

# Selecting outcomes from composite scales
outcome_vars <- scale_data %>% slice(c(3:6,12,13,164)) %>% select(variable_categorical,variable_numeric) %>%  unlist()%>% na.omit() %>% as.vector()
```


```{r}
# Participants identified as sexual or gender minorities at baseline, subsequent waves asked about trans identity and sexual orientation direclty
which_datasets_group(c("DEMO_gender","DEMO_orientation","DEMO_gender_trans","DEMO_identity_lgbtq"))

data$LGBTQ <- rep(FALSE, nrow(data))

data$LGBTQ[data$DEMO_orientation %in% c("Gay or Lesbian", "Bisexual or Queer", "Asexual", "Questioning") & !is.na(data$DEMO_orientation)] <- TRUE
data$LGBTQ[data$DEMO_gender_trans=="Yes" & !is.na(data$DEMO_gender_trans)] <- TRUE
data$LGBTQ[data$DEMO_gender=="Non-binary" & !is.na(data$DEMO_gender)] <- TRUE
data$LGBTQ[data$DEMO_identity_lgbtq=="Sexual or gender minorities (e.g., LGBTQ2+)" & !is.na(data$DEMO_identity_lgbtq)] <- TRUE
data$LGBTQ[is.na(data$DEMO_orientation) & is.na(data$DEMO_gender_trans) & is.na(data$DEMO_gender) & is.na(data$DEMO_identity_lgbtq)] <- NA


```
Study 1. Cross-sectional data

```{r}

# Selecting cross sectional data and relevant variables, including demographic and geographic data
cross <- data %>% filter(grepl("Cross",DATASET)) %>% select(UNIQUE_id, LGBTQ,starts_with("DEMO_"),WORK_hours_per_week,starts_with("GEO_"),all_of(social_patterns_vars), all_of(outcome_vars),DATASET) %>% droplevels.data.frame()

# Deleting empty columns
cross <- cross %>% select(-all_of(names(cross)[colSums(is.na(cross)) == nrow(cross)]))

# Identifying columns that do not appear in all waves 
miss_cols <- c()
for(i in levels(cross$DATASET)){
  df <- cross %>% filter(DATASET==i)
all_na_cols <- names(df)[colSums(is.na(df)) == nrow(df)]  
miss_cols <- c(miss_cols,all_na_cols)
}

# Deleting columns that do not appear in all cross sections
cross <- cross %>% select(-all_of(miss_cols)) %>% select(-starts_with("GEO_commute"), -ends_with("_y_n"))


# 2240 participants (19.4%) did not provide information on gender or sexual orientation
# table(cross$LGBTQ,useNA = "always")
# prop.table(table(cross$LGBTQ,useNA = "always"))
```

```{r}
levels(cross$DEMO_ethnicity)[levels(cross$DEMO_ethnicity) %in% c("Chinese", "Japanese", "Korean")] <- "East Asian"
levels(cross$DEMO_ethnicity)[levels(cross$DEMO_ethnicity) %in% c("Filipino", "Southeast Asian (e.g., Vietnamese, Cambodian, Laotian, Thai, etc.)")] <- "Southeast Asian"
levels(cross$DEMO_ethnicity)[levels(cross$DEMO_ethnicity) %in% c("South Asian (e.g., East Indian, Pakistani, Sri Lankan, etc.)", "West Asian (e.g., Iranian, Afghan, etc.)")] <- "South Asian and West Asian"
levels(cross$DEMO_ethnicity)[levels(cross$DEMO_ethnicity) %in% c("Arab", "None of the above")] <- "Other"

levels(cross$DEMO_household_income)[21:25] <- "$150,000 to $199,999"
levels(cross$DEMO_household_income)[16:20] <- "$100,000 to $149,999" 
levels(cross$DEMO_household_income)[12:15] <- "$60,000 to $99,999"
levels(cross$DEMO_household_income)[9:11] <- "$40,000 to $59,999"
levels(cross$DEMO_household_income)[5:8] <- "$20,000 to $39,999"
levels(cross$DEMO_household_income)[1:4] <- "Under $20,000"

cross <- cross %>% mutate(WORK_hours_per_week=factor(case_when(
  WORK_hours_per_week==0 ~ "Unemployed",
  WORK_hours_per_week<20 ~ "Works <20 h/week",
  WORK_hours_per_week<=168 ~ "Works 20 h/week or more",
  TRUE ~ NA
)))

# Creating categorical variables for age
cross <- cross %>%
  mutate(DEMO_age_group = factor(cut(
    DEMO_age,
    breaks = c(16, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, Inf),
    labels = c(
      "16–19", "20–24", "25–29", "30–34", "35–39",
      "40–44", "45–49", "50–54", "55–59", "60–64", "65+"
    ),
    right = FALSE
  ), ordered = T)) %>% relocate(DEMO_age_group, .after = DEMO_age)


cross <- cross %>% mutate(DEMO_age_group_2=factor(case_when(
  DEMO_age<30 ~ "< 30 years",
  DEMO_age %in% c(30:59) ~ "30 to 59 years",
  DEMO_age %in% c(60:100) ~ "60 and older",
  TRUE ~ NA
))) %>% relocate(DEMO_age_group_2, .after = DEMO_age_group)

levels(cross$DEMO_orientation)[levels(cross$DEMO_orientation) %in% c("Asexual", "Questioning", "None")] <- "None of the above"

levels(cross$DEMO_relationship_status)[levels(cross$DEMO_relationship_status)=="Single and dating"] <- "In a relationship"

levels(cross$GEO_province)[levels(cross$GEO_province) %in% c("Yukon", "Northwest Territories", "Nunavut")] <- "Territories"

cross <- cross %>% mutate(GEO_housing_household_size=factor(case_when(is.na(GEO_housing_household_size) ~ NA_character_,
                                                                GEO_housing_household_size==0 ~ "Alone",
                                                                GEO_housing_household_size==1 ~ "1 other person",
                                                                TRUE ~ "2 other people or more"),levels = c("Alone", "1 other person", "2 other people or more"), ordered = T))

cross <- cross %>% dplyr::mutate(DEMO_gender_so = factor(case_when(
  DEMO_gender=="Non-binary" ~ "Non-binary",
  LGBTQ==T & DEMO_gender=="Woman"~ "2SLGBTQ+ Women",
  LGBTQ==T & DEMO_gender=="Man" ~ "2SLGBTQ+ Men",
  LGBTQ==F & DEMO_gender=="Man" ~ "Cis-Het Men",
  LGBTQ==F & DEMO_gender=="Woman" ~ "Cis-Het Women",
  TRUE ~ NA))) %>% select(-DEMO_gender,-DEMO_orientation, -LGBTQ) %>% relocate(DEMO_gender_so, .before = DEMO_ethnicity) %>% droplevels.data.frame()

```


```{r}
demo_vars <- colnames(cross)[c(2,5:14)] #contains 3 variables for age
# Looking at differences between those with and without missing data
cross <- cross %>% mutate(missing_outcome =  is.na(LONELY_dejong_emotional_loneliness_sub_scale_score) | is.na(LONELY_dejong_social_loneliness_sub_scale_score)) 
#%>% 
#  mutate(missing_exposure = is.na(LGBTQ) | DEMO_gender=="Presented but no response" | DEMO_orientation=="Presented but no response" |is.na(DEMO_gender) | is.na(DEMO_orientation))
# missing_data_table <- cross %>% mutate(missing=missing_exposure==T | missing_outcome==T) %>% CreateTableOne(vars = c(demo_vars,"missing_outcome"), strata = "missing", data = ., includeNA = F)

missing_data_table <- cross %>% CreateTableOne(vars = demo_vars, strata = "missing_outcome", data = ., includeNA = F)

missing_data_table
tab_csv <- print(missing_data_table, printToggle = FALSE)
write.csv(tab_csv, file = here("cscs","patterns_social_connection","cscs_cross_2025_missing_outcome.csv"))

# missing_outcome_table_2 <- cross %>% filter(missing_exposure==F) %>% CreateTableOne(vars = c(demo_vars), strata = "missing_outcome", data = ., includeNA = F)
# missing_outcome_table_2


```

```{r}
# Creating  the analytic file
df <- cross
df[df=="Presented but no response"] <- NA
# df <-df %>% filter(missing_exposure==F & missing_outcome==F) %>% droplevels.data.frame() %>% select(-starts_with("missing_"),-GEO_residence_canada) 

df <-df %>% filter(missing_outcome==F) %>% droplevels.data.frame() %>% select(-starts_with("missing_"),-GEO_residence_canada) #GEO_residence_canada is excluded due to all being Canadian
```

Below we see the characteristics of participants missing outcome information, they are significantly younger that those who did provide outcome data, more likely to identify as "Man", ]to be single and dating, to identify as White, to be less educated, less likely to work full-time (provincial differences not reported).

```{r}
descr_tab <- df %>% CreateTableOne(vars = c(demo_vars, "LONELY_dejong_emotional_loneliness_sub_scale_score",
"LONELY_dejong_social_loneliness_sub_scale_score","WELLNESS_phq_score","WELLNESS_gad_score","WELLNESS_life_satisfaction_num"), strata = "DATASET", data = ., includeNA = F, test = F, addOverall = T)

tab_1_csv <- print(descr_tab, printToggle = FALSE)
write.csv(tab_1_csv, file = here("cscs","patterns_social_connection","cscs_cross_2025_t1.csv"))
```


# Dealing with Missing Data 
```{r}
# Imputation

missing_info <- DataExplorer::profile_missing(df)
#View(missing_info)
if(file.exists(file = here("cscs","patterns_social_connection","cscs_cross_2025_imputed.RDS"))){
  df_imputed <- readRDS(here("cscs","patterns_social_connection","cscs_cross_2025_imputed.RDS"))} else {
    
    p_load(parallel)
    p_load(doParallel)  
    p_load(foreach) 
    total_cores <- detectCores()
    used_cores <- floor(0.75 * total_cores)
    cl <- makeCluster(used_cores)
    registerDoParallel(cl)
    
    df_temp <- df %>% select(-DEMO_age_group,-DEMO_age_group_2, -UNIQUE_id)
    #naniar::mcar_test(df_temp) p is 1, listwise deletion is recommended
    #Among those with outcome, missing data is MCAR

    p_load(missForest)
    set(986) #added later OOB might change slightly
    miss_df <- missForest(df_temp, verbose=T,parallelize = "forests", variablewise = T)
    mean(miss_df$OOBerror[11:39]) #PFC
    mean(sqrt(miss_df$OOBerror[43])/6,sqrt(miss_df$OOBerror[44])/6, sqrt(miss_df$OOBerror[45])/9) #NRMSE
    
    df_imputed <- miss_df$ximp
    df_imputed[c("DEMO_age_group", "DEMO_age_group_2")] <- df[c("DEMO_age_group", "DEMO_age_group_2")]
    saveRDS(df_imputed, file = here("cscs","patterns_social_connection","cscs_cross_2025_imputed.RDS"))
    stopCluster(cl)
    }

# Listwise deletion
ids_complete <- df %>% select(UNIQUE_id, starts_with("CONNECTION_"), starts_with("WELLNESS_"), starts_with("LONELY_")) %>%  filter(complete.cases(.)) %>% select(UNIQUE_id) %>% unlist() %>%  as.vector()

df_complete_cases <- df %>% filter(UNIQUE_id %in% ids_complete)

#num_vars <- df_complete_cases %>% select(starts_with("CONNECTION_"), starts_with("WELLNESS_"), starts_with("LONELY_")) %>%  colnames()
#cross %>% select(all_of(num_vars)) %>% naniar::mcar_test()
#MCAR
```


# Reducing data dimensionality
Clustering activities
```{r}
p_load(FactoMineR)
activities_mca <- MCA(df_imputed[activities_vars], graph = F)
coords <- activities_mca$var$coord

p_load(factoextra)
fviz_screeplot(activities_mca, addlabels = TRUE, ylim = c(0, 50))
fviz_nbclust(activities_mca$var$coord, kmeans, method = "wss")
fviz_nbclust(activities_mca$var$coord, kmeans, method = "silhouette") #optimal kmeans is 3
#kmeans_result <- kmeans(coords, centers = 4) #based on conceptual analysis

reduced_activities <- as.data.frame(activities_mca$ind$coord) %>% select(1:4)
colnames(reduced_activities) <- c("activity_avoidance", "activity_social", "activity_physical_intimacy", "activity_emotional_intimacy")
df_imputed <-  cbind(df_imputed,reduced_activities)

# CompleteCASES
activities_mca_cc <- MCA(df_complete_cases[activities_vars], graph = F)
coords_cc <- activities_mca_cc$var$coord
reduced_activities_cc <- as.data.frame(activities_mca_cc$ind$coord) %>% select(1:4)
colnames(reduced_activities_cc) <- colnames(reduced_activities)
df_complete_cases <-  cbind(df_complete_cases,reduced_activities_cc) %>% select(-all_of(activities_vars))


```

Clustering social patterns
```{r}
patterns <- df_imputed %>% select(starts_with("CONNECTION_social")) %>% colnames()
df_imputed[patterns] <- lapply(df_imputed[patterns], as.numeric)

psych::KMO(df_imputed[patterns])
psych::cortest.bartlett(cor(df_imputed[patterns]), n = nrow(df_imputed))

pca_social_patterns <- prcomp(df_imputed[patterns],center = TRUE,scale. = T)
summary(pca_social_patterns)

#Eigenvalues
(pca_social_patterns$sdev[pca_social_patterns$sdev^2 >=1])^2
#First 4 components explain up to 74% of the variance.
pca_scores <- as.data.frame(pca_social_patterns$x[, 1:4])
loadings <- pca_social_patterns$rotation[, 1:4]
# View(loadings)
colnames(pca_scores) <- c("social_disconnection", "casual_socialization", "friend_oriented", "family_oriented") 
df_imputed <- cbind(df_imputed,pca_scores) 
loadings %>% clipr::write_clip()

# CompleteCASES
df_complete_cases[patterns] <- lapply(df_complete_cases[patterns], as.numeric)
pca_social_patterns_cc <- prcomp(df_complete_cases[patterns],center = TRUE,scale. = T)
pca_scores_cc <- as.data.frame(pca_social_patterns_cc$x[, 1:4])
loadings_cc <- pca_social_patterns_cc$rotation[, 1:4]
colnames(pca_scores_cc) <- colnames(pca_scores) 
df_complete_cases <- cbind(df_complete_cases,pca_scores_cc) %>% select(-all_of(patterns)) 


```
Creating a simplified numeric dataset
```{r}
df_simplified <- df_imputed %>% select(all_of(c(colnames(pca_scores), colnames(reduced_activities))), ends_with("sub_scale_score"), starts_with("WELLNESS"))

##################  COMPLETE CASES  ##################
# df_simplified_cc <- df_complete_cases %>% select(all_of(colnames(df_simplified)))
######################################################

colnames(df_simplified) <- sub("LONELY_dejong_","",colnames(df_simplified))
colnames(df_simplified) <- sub("_sub_scale_score","",colnames(df_simplified))
colnames(df_simplified) <- sub("WELLNESS_","",colnames(df_simplified))
colnames(df_simplified) <- sub("_num","",colnames(df_simplified))

##################  COMPLETE CASES  ##################
# colnames(df_simplified_cc) <- colnames(df_simplified)
# corp_cc <- plot_correlation(df_simplified_cc)
######################################################

corp <- plot_correlation(df_simplified)
ggsave(here("cscs","patterns_social_connection","cscs_cross_2025_correlation_plot.png"), plot = corp, width = 3000, height = 3000, units = "px", dpi = 300)

p_load(bnlearn)

strenght <- boot.strength(df_simplified, R=500, algorithm = "hc") #misspelling to avoid functions
avg_bn <- averaged.network(strenght, threshold = 0.85)

##################  COMPLETE CASES  ##################
# cc_boot <- boot.strength(df_simplified_cc, R=500, algorithm = "hc") 
# cc_avg_bn <- averaged.network(cc_boot, threshold = 0.85)
######################################################

##################  COMBINED DATASETS  ##################
# cc_boot_all <- rbind(cc_boot, strenght)
# avg_all <- averaged.network(cc_boot_all, threshold = 0.85)
# graphviz.plot(avg_bn)
# graphviz.plot(cc_avg_bn)
# graphviz.plot(avg_all)
########################################################

fitted_model <- bn.fit(avg_bn,data = df_simplified)
arcs_neg <- matrix(ncol=2)
colnames(arcs_neg) <- c("Var1", "Var2")
for(i in c(1:13)){
  node <- fitted_model[[i]]$node
  coeff <- fitted_model[[i]]$coefficients[fitted_model[[i]]$coefficients <0]
  
x <- expand.grid(names(coeff)[names(coeff) != "(Intercept)"],node)
arcs_neg <- rbind(arcs_neg,x)
}
arcs_neg <- arcs_neg[-1,]
colnames(arcs_neg) <- c("from", "to")
p_load(BiocManager)
p_load(Rgraphviz)


png(here("cscs","patterns_social_connection","cscs_cross_2025_dag_plot.png"), width = 800, height = 800, units = "px", res = 300)
graphviz.plot(fitted_model, highlight = list(arcs=as.matrix(arcs_neg), nodes=c("emotional_loneliness", "social_loneliness")))
dev.off()

fitted_model$emotional_loneliness
fitted_model$social_loneliness

```

END OF CODE IN THE PAPER 

# Variable selection through random forest
```{r}
p_load(Boruta)
social_loneliness_vars <- Boruta(social_loneliness ~ ., 
                        data = df_simplified %>% select(-emotional_loneliness),
                        doTrace = 0,
                        maxRuns = 50)

emotional_loneliness_vars <- Boruta(emotional_loneliness ~ ., 
                        data = df_simplified %>% select(-social_loneliness),
                        doTrace = 0,
                        maxRuns = 50)

```

A blacklist of directional constraints was defined a priori to prevent implausible or non-causal arcs. Specifically, we disallowed edges pointing from modifiable or behavioral variables to demographic variables assumed to be determined at birth (e.g., age group and ethnicity), and restricted reciprocal arcs between some demographic variables. Additional constraints were applied to prevent behavioral or psychosocial predictors from being modeled as causes of gender identity or sexual orientation.  

```{r}

df_factor <- df_imputed %>% select(-starts_with("CONNECTION_"), -exposure, -LGBTQ, ,-LONELY_dejong_emotional_social_loneliness_scale_score, -DEMO_age,-DEMO_age_group_2, -GEO_province, -DATASET)


for (var in colnames(df_factor)[16:23]){
df_factor[[var]] <- scales::rescale(df_factor[[var]], to = c(-2, 2))
df_factor[[var]] <- factor(round(df_factor[[var]]), ordered = T)
}

for (var in c("WELLNESS_phq_score","WELLNESS_gad_score","WELLNESS_life_satisfaction_num")){
df_factor[[var]] <- scales::rescale(df_factor[[var]], to = c(0, 6))
df_factor[[var]] <- factor(round(df_factor[[var]]), ordered = T)
}

born_with_factor <- c("DEMO_age_group", "DEMO_ethnicity") # "gender" and "orientation" are not included because we assumed other variables influence reporting
other_vars_factor <- colnames(df_factor)[!colnames(df_factor) %in% born_with_factor]

blacklistf <- expand.grid(
  from = other_vars_factor,
  to = born_with_factor
)

blacklistf <- rbind(blacklistf, expand.grid(
  from = born_with_factor,
  to = born_with_factor
))

not_demo_vars <- df_factor %>% select(-starts_with("DEMO")) %>% colnames()

blacklistf <- rbind(blacklistf, expand.grid(
  from = c(not_demo_vars,"DEMO_relationship_status"),
  to = c("DEMO_gender", "DEMO_orientation")
))


df_factor <-  as.data.frame(lapply(df_factor, function(x) {
  if (is.numeric(x)) as.factor(x) else x
}))

BN_500 <- boot.strength(df_factor, R=500, algorithm = "hc", algorithm.args = list(blacklist=blacklistf))
avg_factor <- averaged.network(BN_500, threshold = 0.85)

dag_factor <- hc(df_factor,blacklist = blacklistf, score = "bic")
arc_factor <- arc.strength(dag_factor, data = df_factor, criterion = "bic")
# Plot the result

graphviz.plot(dag_factor, fontsize = 20)
fitted_model_factor <- bn.fit(dag_factor, df_factor)
fitted_model_factor$LONELY_dejong_emotional_loneliness_sub_scale_score
fitted_model_factor$LONELY_dejong_social_loneliness_sub_scale_score
```
```{r}
library(reshape2)

# Extract the CPT
cpt <- fitted_model_factor$LONELY_dejong_social_loneliness_sub_scale_score$prob

# Convert to data.frame
df_cpt <- as.data.frame(as.table(cpt))
df_cpt2 <- fitted_model_factor$LONELY_dejong_emotional_loneliness_sub_scale_score$prob %>% as.data.frame()

# Rename for clarity
colnames(df_cpt) <- c("Social_Loneliness", "Life_Satisfaction", "Activity_Avoidance", "Probability")

colnames(df_cpt2)<- c("Emotional_Loneliness", "Age_group", "Probability") 
# Plot as heatmap

plot_sl <- ggplot(df_cpt, aes(x = Life_Satisfaction, y = Activity_Avoidance, fill = Probability)) +
  geom_tile(color = "white") +
  facet_wrap(~ Social_Loneliness) +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Conditional probabilities of Social Loneliness")

plot_el <- ggplot(df_cpt2, aes(x = Age_group, y = Emotional_Loneliness, fill = Probability)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Conditional probabilities of Emotional Loneliness")

```




#Optional RANDOM FOREST direct analysis
```{r eval=FALSE, include=TRUE}
p_load(randomForest)
p_load(caret)

set.seed(123)


# Set up tuning grid
tune_grid <- expand.grid(mtry = c(2, 4, 6, 8, 10))

# Train model using 5-fold cross-validation
ctrl <- trainControl(method = "cv", number = 5, classProbs = TRUE, summaryFunction = multiClassSummary)

rf_social_loneliness_model <- train(
  social_loneliness ~ ., 
  data = df_simplified %>% select(-emotional_loneliness),
  method = "rf",
  trControl = ctrl,
  tuneGrid = tune_grid,
  metric = "Kappa", 
  ntree = 500
)

rf_emotional_loneliness_model <- train(
  emotional_loneliness ~ ., 
  data = df_simplified %>% select(-social_loneliness),
  method = "rf",
  trControl = ctrl,
  tuneGrid = tune_grid,
  metric = "Kappa", 
  ntree = 500
)

# Review results
social_imp_vars <- varImp(rf_social_loneliness_model)$importance
social_imp_vars$prop <- social_imp_vars$Overall/sum(social_imp_vars$Overall)

social_imp_vars$Include <- ifelse(social_imp_vars$Overall >=(max(social_imp_vars$Overall)*.1),T,F)

emo_imp_vars <- varImp(rf_emotional_loneliness_model)$importance
emo_imp_vars$Include <- ifelse(emo_imp_vars$Overall >=(max(emo_imp_vars$Overall)*.1),T,F)


```

# PCA with p3m
```{r}
p3m_vars <- which_datasets_group(activities_past_three_months) %>% filter(baseline==T & cross23==T & cross24==T) %>% select(variable_name) %>% unlist() %>%  as.vector()

tdf <- data %>% filter(grepl("Cross",DATASET)) %>% select(all_of(p3m_vars)) %>% filter(complete.cases(.))
ttdf <- tdf
for (var in colnames(tdf)){
  levels(tdf[[var]])[levels(tdf[[var]])=="Presented but no response"] <- NA
  tdf[[var]] <- as.numeric(tdf[[var]])
}

table(tdf[[1]])
table(ttdf[[1]])
tdf <- tdf %>% filter(complete.cases(.))
colnames(tdf) <- sub("CONNECTION_activities_","",colnames(tdf))
colnames(tdf) <- sub("_p3m","",colnames(tdf))

pca_p3m <- prcomp(tdf,center = TRUE,scale. = T)
summary(pca_p3m)
#Eigenvalues
pca_p3m$sdev^2 # 3 meaningful components per the K1 rule  
#First 3 components explain up to 53.7% of the variance. Fourth component explains an extra 4.9%

p3m_scores <- as.data.frame(pca_p3m$x[, 1:4])
p3m_loadings <- pca_p3m$rotation[, 1:4]
View(p3m_loadings)
```

# Plotting loneliness across the lifecourse
```{r}
p_load(ggplot2)

emo_l <- ggplot(df, aes(x = as.numeric(DEMO_age_group), y = LONELY_dejong_emotional_loneliness_sub_scale_score, color = exposure, fill = exposure)) +
  geom_smooth(se = F) +
  ylab("Emotional Loneliness Score") +
  xlab("Age Group") +
  scale_x_continuous(breaks = 1:11, labels = levels(df$DEMO_age_group)) + 
  theme_minimal() 

social_l <- ggplot(df, aes(x = as.numeric(DEMO_age_group), y = LONELY_dejong_social_loneliness_sub_scale_score, color = exposure, fill = exposure)) +
  geom_smooth(se = F) +
  ylab("Social Loneliness Score") +
  xlab("Age Group") +
  scale_x_continuous(breaks = 1:11, labels = levels(df$DEMO_age_group)) + 
  theme_minimal()

p_load(patchwork)
p3 <- emo_l +social_l+ plot_layout(nrow = 2)
suppressWarnings(suppressMessages(print(p3))) 
```
